{
  "language": "Solidity",
  "sources": {
    "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "lib/solmate/src/utils/Bytes32AddressLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Library for converting between addresses and bytes32 values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/Bytes32AddressLib.sol)\nlibrary Bytes32AddressLib {\n    function fromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    function fillLast12Bytes(address addressValue) internal pure returns (bytes32) {\n        return bytes32(bytes20(addressValue));\n    }\n}\n"
    },
    "lib/solmate/src/utils/CREATE3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {Bytes32AddressLib} from \"./Bytes32AddressLib.sol\";\n\n/// @notice Deploy to deterministic addresses without an initcode factor.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/CREATE3.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol)\nlibrary CREATE3 {\n    using Bytes32AddressLib for bytes32;\n\n    //--------------------------------------------------------------------------------//\n    // Opcode     | Opcode + Arguments    | Description      | Stack View             //\n    //--------------------------------------------------------------------------------//\n    // 0x36       |  0x36                 | CALLDATASIZE     | size                   //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 0 size               //\n    // 0x37       |  0x37                 | CALLDATACOPY     |                        //\n    // 0x36       |  0x36                 | CALLDATASIZE     | size                   //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //\n    // 0x34       |  0x34                 | CALLVALUE        | value 0 size           //\n    // 0xf0       |  0xf0                 | CREATE           | newContract            //\n    //--------------------------------------------------------------------------------//\n    // Opcode     | Opcode + Arguments    | Description      | Stack View             //\n    //--------------------------------------------------------------------------------//\n    // 0x67       |  0x67XXXXXXXXXXXXXXXX | PUSH8 bytecode   | bytecode               //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 bytecode             //\n    // 0x52       |  0x52                 | MSTORE           |                        //\n    // 0x60       |  0x6008               | PUSH1 08         | 8                      //\n    // 0x60       |  0x6018               | PUSH1 18         | 24 8                   //\n    // 0xf3       |  0xf3                 | RETURN           |                        //\n    //--------------------------------------------------------------------------------//\n    bytes internal constant PROXY_BYTECODE = hex\"67_36_3d_3d_37_36_3d_34_f0_3d_52_60_08_60_18_f3\";\n\n    bytes32 internal constant PROXY_BYTECODE_HASH = keccak256(PROXY_BYTECODE);\n\n    function deploy(\n        bytes32 salt,\n        bytes memory creationCode,\n        uint256 value\n    ) internal returns (address deployed) {\n        bytes memory proxyChildBytecode = PROXY_BYTECODE;\n\n        address proxy;\n        assembly {\n            // Deploy a new contract with our pre-made bytecode via CREATE2.\n            // We start 32 bytes into the code to avoid copying the byte length.\n            proxy := create2(0, add(proxyChildBytecode, 32), mload(proxyChildBytecode), salt)\n        }\n        require(proxy != address(0), \"DEPLOYMENT_FAILED\");\n\n        deployed = getDeployed(salt);\n        (bool success, ) = proxy.call{value: value}(creationCode);\n        require(success && deployed.code.length != 0, \"INITIALIZATION_FAILED\");\n    }\n\n    function getDeployed(bytes32 salt) internal view returns (address) {\n        address proxy = keccak256(\n            abi.encodePacked(\n                // Prefix:\n                bytes1(0xFF),\n                // Creator:\n                address(this),\n                // Salt:\n                salt,\n                // Bytecode hash:\n                PROXY_BYTECODE_HASH\n            )\n        ).fromLast20Bytes();\n\n        return\n            keccak256(\n                abi.encodePacked(\n                    // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01)\n                    // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n                    hex\"d6_94\",\n                    proxy,\n                    hex\"01\" // Nonce of the proxy contract (1)\n                )\n            ).fromLast20Bytes();\n    }\n}\n"
    },
    "src/timelocks/interface/ITimelockedDelegator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.19;\n\nimport {IERC20} from \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\ninterface IDelegatable is IERC20 {\n  function delegate(address delegatee) external;\n}\n\n/// @title TimelockedDelegator interface\n/// @author Fei Protocol\n/// @dev Modified from: https://github.com/fei-protocol/fei-protocol-core/blob/develop/contracts/timelocks/ITimelockedDelegator.sol\ninterface ITimelockedDelegator {\n  // ----------- Events -----------\n\n  event Delegate(address indexed _delegatee, uint256 _amount);\n\n  event Undelegate(address indexed _delegatee, uint256 _amount);\n\n  // ----------- Beneficiary only state changing api -----------\n\n  function delegate(address delegatee, uint256 amount) external;\n\n  function undelegate(address delegatee) external returns (uint256);\n\n  // ----------- Getters -----------\n\n  function delegateContract(address delegatee) external view returns (address);\n\n  function delegateAmount(address delegatee) external view returns (uint256);\n\n  function totalDelegated() external view returns (uint256);\n\n  function token() external view returns (IDelegatable);\n}\n"
    },
    "src/timelocks/interface/ITokenTimelock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.19;\n\nimport {IERC20} from \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\n/// @title TokenTimelock interface\n/// @author Fei Protocol\n/// @dev Modified from: https://github.com/fei-protocol/fei-protocol-core/blob/develop/contracts/timelocks/ITokenTimelock.sol\ninterface ITokenTimelock {\n  // ----------- Events -----------\n\n  event Release(address indexed _beneficiary, address indexed _recipient, uint256 _amount);\n  event BeneficiaryUpdate(address indexed _beneficiary);\n  event PendingBeneficiaryUpdate(address indexed _pendingBeneficiary);\n\n  // ----------- State changing api -----------\n\n  function release(address to, uint256 amount) external;\n\n  function releaseMax(address to) external;\n\n  function setPendingBeneficiary(address _pendingBeneficiary) external;\n\n  function acceptBeneficiary() external;\n\n  // ----------- Getters -----------\n\n  function lockedToken() external view returns (IERC20);\n\n  function beneficiary() external view returns (address);\n\n  function pendingBeneficiary() external view returns (address);\n\n  function initialBalance() external view returns (uint256);\n\n  function availableForRelease() external view returns (uint256);\n\n  function totalToken() external view returns (uint256);\n\n  function alreadyReleasedAmount() external view returns (uint256);\n}\n"
    },
    "src/timelocks/LinearTokenTimelock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.19;\n\nimport \"./TokenTimelock.sol\";\n\n/// Modified from: https://github.com/fei-protocol/fei-protocol-core/blob/develop/contracts/timelocks/LinearTokenTimelock.sol\n/// @author Fei Protocol\ncontract LinearTokenTimelock is TokenTimelock {\n  constructor(\n    address _beneficiary,\n    uint256 _duration,\n    address _lockedToken,\n    uint256 _cliffDuration,\n    address _clawbackAdmin,\n    uint256 _startTime\n  ) TokenTimelock(_beneficiary, _duration, _cliffDuration, _lockedToken, _clawbackAdmin) {\n    if (_startTime != 0) {\n      startTime = _startTime;\n    }\n  }\n\n  function _proportionAvailable(\n    uint256 initialBalance,\n    uint256 elapsed,\n    uint256 duration\n  ) internal pure override returns (uint256) {\n    return (initialBalance * elapsed) / duration;\n  }\n}\n"
    },
    "src/timelocks/Timed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.19;\n\n/// @title an abstract contract for timed events\n/// @author Fei Protocol\n/// @dev Modified from: https://github.com/fei-protocol/fei-protocol-core/blob/develop/contracts/utils/Timed.sol\nabstract contract Timed {\n  /// @notice the start timestamp of the timed period\n  uint256 public startTime;\n\n  /// @notice the duration of the timed period\n  uint256 public duration;\n\n  event DurationUpdate(uint256 oldDuration, uint256 newDuration);\n\n  event TimerReset(uint256 startTime);\n\n  constructor(uint256 _duration) {\n    _setDuration(_duration);\n  }\n\n  modifier duringTime() {\n    require(isTimeStarted(), \"Timed: time not started\");\n    require(!isTimeEnded(), \"Timed: time ended\");\n    _;\n  }\n\n  modifier afterTime() {\n    require(isTimeEnded(), \"Timed: time not ended\");\n    _;\n  }\n\n  /// @notice return true if time period has ended\n  function isTimeEnded() public view returns (bool) {\n    return remainingTime() == 0;\n  }\n\n  /// @notice number of seconds remaining until time is up\n  /// @return remaining\n  function remainingTime() public view returns (uint256) {\n    return duration - timeSinceStart(); // duration always >= timeSinceStart which is on [0,d]\n  }\n\n  /// @notice number of seconds since contract was initialized\n  /// @return timestamp\n  /// @dev will be less than or equal to duration\n  function timeSinceStart() public view returns (uint256) {\n    if (!isTimeStarted()) {\n      return 0; // uninitialized\n    }\n    uint256 _duration = duration;\n    uint256 timePassed = block.timestamp - startTime; // block timestamp always >= startTime\n    return timePassed > _duration ? _duration : timePassed;\n  }\n\n  function isTimeStarted() public view returns (bool) {\n    return startTime != 0;\n  }\n\n  function _initTimed() internal {\n    startTime = block.timestamp;\n\n    emit TimerReset(block.timestamp);\n  }\n\n  function _setDuration(uint256 newDuration) internal {\n    require(newDuration != 0, \"Timed: zero duration\");\n\n    uint256 oldDuration = duration;\n    duration = newDuration;\n    emit DurationUpdate(oldDuration, newDuration);\n  }\n}\n"
    },
    "src/timelocks/TimelockedDelegator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.19;\n\nimport {Ownable} from \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport {ITimelockedDelegator, IDelegatable} from \"./interface/ITimelockedDelegator.sol\";\nimport {LinearTokenTimelock} from \"./LinearTokenTimelock.sol\";\n\n/// @title a proxy delegate contract for token\n/// @author Fei Protocol, modified by Connext. Fei reference:\n///         https://github.com/fei-protocol/fei-protocol-core/blob/develop/contracts/timelocks/LinearTimelockedDelegator.sol\n/// @dev https://eips.ethereum.org/EIPS/eip-4758 -> inclusion seems likely within\n///      the next 4 years, so selfdestruct was removed from withdraw()\n/// @dev\ncontract Delegatee is Ownable {\n  IDelegatable public token;\n\n  /// @notice Delegatee constructor\n  /// @param _delegatee the address to delegate token to\n  /// @param _token the delegatable token address\n  constructor(address _delegatee, address _token) {\n    token = IDelegatable(_token);\n    token.delegate(_delegatee);\n  }\n\n  /// @notice send token back to timelock\n  function withdraw() public onlyOwner {\n    IDelegatable _token = token;\n    uint256 balance = _token.balanceOf(address(this));\n    _token.transfer(owner(), balance);\n  }\n}\n\n/// @title a timelock for token allowing for sub-delegation\n/// @author Fei Protocol\n/// @notice allows the timelocked token to be delegated by the beneficiary while locked\ncontract TimelockedDelegator is ITimelockedDelegator, LinearTokenTimelock {\n  /// @notice associated delegate proxy contract for a delegatee\n  mapping(address => address) public override delegateContract;\n\n  /// @notice associated delegated amount of token for a delegatee\n  /// @dev Using as source of truth to prevent accounting errors by transferring to Delegate contracts\n  mapping(address => uint256) public override delegateAmount;\n\n  /// @notice the token contract\n  IDelegatable public override token;\n\n  /// @notice the total delegated amount of token\n  uint256 public override totalDelegated;\n\n  /// @notice Delegatee constructor\n  /// @param _token the token address\n  /// @param _beneficiary default delegate, admin, and timelock beneficiary\n  /// @param _clawbackAdmin who can withdraw unclaimed tokens if timelock halted. use address(0) if there\n  ///        shouldn't be clawbacks for this contract\n  /// @param _cliffDuration cliff of unlock, in seconds. Use 0 for no cliff.\n  /// @param _startTime start time of unlock period, in seconds. Use 0 for now.\n  /// @param _duration duration of the token timelock window\n  constructor(\n    address _token,\n    address _beneficiary,\n    address _clawbackAdmin,\n    uint256 _cliffDuration,\n    uint256 _startTime,\n    uint256 _duration\n  ) LinearTokenTimelock(_beneficiary, _duration, _token, _cliffDuration, _clawbackAdmin, _startTime) {\n    token = IDelegatable(_token);\n    token.delegate(_beneficiary);\n  }\n\n  /// @notice delegate locked token to a delegatee\n  /// @param delegatee the target address to delegate to\n  /// @param amount the amount of token to delegate. Will increment existing delegated token\n  function delegate(address delegatee, uint256 amount) public override onlyBeneficiary {\n    require(amount <= _tokenBalance(), \"TimelockedDelegator: Not enough balance\");\n\n    // withdraw and include an existing delegation\n    if (delegateContract[delegatee] != address(0)) {\n      amount = amount + undelegate(delegatee);\n    }\n\n    IDelegatable _token = token;\n    address _delegateContract = address(new Delegatee(delegatee, address(_token)));\n    delegateContract[delegatee] = _delegateContract;\n\n    delegateAmount[delegatee] = amount;\n    totalDelegated = totalDelegated + amount;\n\n    _token.transfer(_delegateContract, amount);\n\n    emit Delegate(delegatee, amount);\n  }\n\n  /// @notice return delegated token to the timelock\n  /// @param delegatee the target address to undelegate from\n  /// @return the amount of token returned\n  function undelegate(address delegatee) public override onlyBeneficiary returns (uint256) {\n    address _delegateContract = delegateContract[delegatee];\n    require(_delegateContract != address(0), \"TimelockedDelegator: Delegate contract nonexistent\");\n\n    Delegatee(_delegateContract).withdraw();\n\n    uint256 amount = delegateAmount[delegatee];\n    totalDelegated = totalDelegated - amount;\n\n    delegateContract[delegatee] = address(0);\n    delegateAmount[delegatee] = 0;\n\n    emit Undelegate(delegatee, amount);\n\n    return amount;\n  }\n\n  /// @notice calculate total token held plus delegated\n  /// @dev used by LinearTokenTimelock to determine the released amount\n  function totalToken() public view override returns (uint256) {\n    return _tokenBalance() + totalDelegated;\n  }\n\n  /// @notice accept beneficiary role over timelocked token. Delegates all held (non-subdelegated) token to beneficiary\n  function acceptBeneficiary() public override {\n    _setBeneficiary(msg.sender);\n    token.delegate(msg.sender);\n  }\n\n  function _tokenBalance() internal view returns (uint256) {\n    return token.balanceOf(address(this));\n  }\n}\n"
    },
    "src/timelocks/TimelockFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {IERC20} from \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport {CREATE3} from \"lib/solmate/src/utils/CREATE3.sol\";\n\nimport {TimelockedDelegator} from \"./TimelockedDelegator.sol\";\n\ncontract TimelockFactory {\n  // ============ events ============\n  event TimelockDeployed(\n    address indexed timelock,\n    address indexed token,\n    address indexed beneficiary,\n    address admin,\n    uint256 cliffDuration,\n    uint256 startTime,\n    uint256 duration\n  );\n\n  // ============ public functions ============\n\n  function deployTimelock(\n    address _token,\n    address _beneficiary,\n    address _admin,\n    uint256 _cliffDuration,\n    uint256 _startTime,\n    uint256 _duration,\n    uint256 _funding\n  ) public {\n    address deployed = _deployTimelock(_token, _beneficiary, _admin, _cliffDuration, _startTime, _duration);\n\n    if (_funding > 0) {\n      // fund timelock\n      IERC20(_token).transferFrom(msg.sender, deployed, _funding);\n    }\n  }\n\n  // ============ internal functions ============\n  function _deployTimelock(\n    address _token,\n    address _beneficiary,\n    address _admin,\n    uint256 _cliffDuration,\n    uint256 _startTime,\n    uint256 _duration\n  ) internal returns (address _deployed) {\n    // Get salt\n    bytes32 salt = _getSalt(_token, _beneficiary, _admin, msg.sender);\n\n    // Get bytecode\n    bytes memory bytecode = _getBytecode(_token, _beneficiary, _admin, _cliffDuration, _startTime, _duration);\n\n    // Deploy timelock\n    _deployed = CREATE3.deploy(salt, bytecode, 0);\n    emit TimelockDeployed(_deployed, _token, _beneficiary, _admin, _cliffDuration, _startTime, _duration);\n  }\n\n  function _getSalt(\n    address _token,\n    address _beneficiary,\n    address _admin,\n    address _deployer\n  ) internal pure returns (bytes32 _salt) {\n    _salt = keccak256(abi.encodePacked(_token, _beneficiary, _admin, _deployer));\n  }\n\n  function _getBytecode(\n    address _token,\n    address _beneficiary,\n    address _admin,\n    uint256 _cliffDuration,\n    uint256 _startTime,\n    uint256 _duration\n  ) internal pure returns (bytes memory _bytecode) {\n    _bytecode = abi.encodePacked(\n      type(TimelockedDelegator).creationCode,\n      abi.encode(_token, _beneficiary, _admin, _cliffDuration, _startTime, _duration)\n    );\n  }\n}\n"
    },
    "src/timelocks/TokenTimelock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.19;\n\n// Modified from: https://github.com/fei-protocol/fei-protocol-core/blob/develop/contracts/timelocks/TokenTimelock.sol\n\n// Inspired by OpenZeppelin TokenTimelock contract\n// Reference: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/TokenTimelock.sol\n\nimport {Timed} from \"./Timed.sol\";\nimport {ITokenTimelock, IERC20} from \"./interface/ITokenTimelock.sol\";\n\nabstract contract TokenTimelock is ITokenTimelock, Timed {\n  /// @notice ERC20 basic token contract being held in timelock\n  IERC20 public override lockedToken;\n\n  /// @notice beneficiary of tokens after they are released\n  address public override beneficiary;\n\n  /// @notice pending beneficiary appointed by current beneficiary\n  address public override pendingBeneficiary;\n\n  /// @notice initial balance of lockedToken\n  uint256 public override initialBalance;\n\n  uint256 internal lastBalance;\n\n  /// @notice number of seconds before releasing is allowed\n  uint256 public immutable cliffSeconds;\n\n  address public immutable clawbackAdmin;\n\n  constructor(\n    address _beneficiary,\n    uint256 _duration,\n    uint256 _cliffSeconds,\n    address _lockedToken,\n    address _clawbackAdmin\n  ) Timed(_duration) {\n    require(_duration != 0, \"TokenTimelock: duration is 0\");\n    require(_beneficiary != address(0), \"TokenTimelock: Beneficiary must not be 0 address\");\n\n    beneficiary = _beneficiary;\n    _initTimed();\n\n    _setLockedToken(_lockedToken);\n\n    cliffSeconds = _cliffSeconds;\n\n    clawbackAdmin = _clawbackAdmin;\n  }\n\n  // Prevents incoming LP tokens from messing up calculations\n  modifier balanceCheck() {\n    if (totalToken() > lastBalance) {\n      uint256 delta = totalToken() - lastBalance;\n      initialBalance = initialBalance + delta;\n    }\n    _;\n    lastBalance = totalToken();\n  }\n\n  modifier onlyBeneficiary() {\n    require(msg.sender == beneficiary, \"TokenTimelock: Caller is not a beneficiary\");\n    _;\n  }\n\n  /// @notice releases `amount` unlocked tokens to address `to`\n  function release(address to, uint256 amount) external override onlyBeneficiary balanceCheck {\n    require(amount != 0, \"TokenTimelock: no amount desired\");\n    require(passedCliff(), \"TokenTimelock: Cliff not passed\");\n\n    uint256 available = availableForRelease();\n    require(amount <= available, \"TokenTimelock: not enough released tokens\");\n\n    _release(to, amount);\n  }\n\n  /// @notice releases maximum unlocked tokens to address `to`\n  function releaseMax(address to) external override onlyBeneficiary balanceCheck {\n    require(passedCliff(), \"TokenTimelock: Cliff not passed\");\n    _release(to, availableForRelease());\n  }\n\n  /// @notice the total amount of tokens held by timelock\n  function totalToken() public view virtual override returns (uint256) {\n    return lockedToken.balanceOf(address(this));\n  }\n\n  /// @notice amount of tokens released to beneficiary\n  function alreadyReleasedAmount() public view override returns (uint256) {\n    return initialBalance == 0 ? 0 : initialBalance - totalToken();\n  }\n\n  /// @notice amount of held tokens unlocked and available for release\n  function availableForRelease() public view override returns (uint256) {\n    uint256 elapsed = timeSinceStart();\n\n    uint256 totalAvailable = _proportionAvailable(initialBalance, elapsed, duration);\n    uint256 netAvailable = totalAvailable - alreadyReleasedAmount();\n    return netAvailable;\n  }\n\n  /// @notice current beneficiary can appoint new beneficiary, which must be accepted\n  function setPendingBeneficiary(address _pendingBeneficiary) public override onlyBeneficiary {\n    pendingBeneficiary = _pendingBeneficiary;\n    emit PendingBeneficiaryUpdate(_pendingBeneficiary);\n  }\n\n  /// @notice pending beneficiary accepts new beneficiary\n  function acceptBeneficiary() public virtual override {\n    _setBeneficiary(msg.sender);\n  }\n\n  function clawback() public balanceCheck {\n    require(msg.sender == clawbackAdmin, \"TokenTimelock: Only clawbackAdmin\");\n    if (passedCliff()) {\n      _release(beneficiary, availableForRelease());\n    }\n    _release(clawbackAdmin, totalToken());\n  }\n\n  function passedCliff() public view returns (bool) {\n    return timeSinceStart() >= cliffSeconds;\n  }\n\n  function _proportionAvailable(\n    uint256 initialBalance,\n    uint256 elapsed,\n    uint256 duration\n  ) internal pure virtual returns (uint256);\n\n  function _setBeneficiary(address newBeneficiary) internal {\n    require(newBeneficiary == pendingBeneficiary, \"TokenTimelock: Caller is not pending beneficiary\");\n    beneficiary = newBeneficiary;\n    emit BeneficiaryUpdate(newBeneficiary);\n    pendingBeneficiary = address(0);\n  }\n\n  function _setLockedToken(address tokenAddress) internal {\n    lockedToken = IERC20(tokenAddress);\n  }\n\n  function _release(address to, uint256 amount) internal {\n    lockedToken.transfer(to, amount);\n    emit Release(beneficiary, to, amount);\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x0000000000000031363933373632333637343930"
      }
    }
  }
}